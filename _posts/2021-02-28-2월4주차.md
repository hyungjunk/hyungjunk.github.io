---
title: 2월 4주차 WIL
---

요번주는 코딩 문제풀이를 위주로 해서 그런가 별 내용이 없다.\
Mock을 이용한 서버리스 함수를 Pytest로 테스트하는 방법을 정리중이었는데 이건 한 번 만들고 나면 따로 올릴 예정이다. 다른 사람들의 코딩 문제풀이를 보다보니 세상엔 참 괴수들이 많다.. ㅇ.ㅇ

## http 1.0, http1.1, http 2.0

http 1.0은 request 보낼때 커넥션 열고 response 보낼 때 커넥션 열고..매 번 뭐 좀 하려고 하면 커넥션을 열었다 닫았다 해야했다. 
집에서 전화로 중국요리를 시킨다고 가정하면 이런 흐름이 아닐까 싶다.

<pre>
여보세요, 거기 중국집이죠? 여기 A동 101호인데 짜장면 하나요
네
(전화 끊고 다시 건 뒤) 여보세요, 거기 중국집이죠? 여기 A동 101호인데 짬뽕 하나요
네
(끊고 다시) 여보세요, 거기 중국집이죠? 여기 A동 101호인데 탕수육 하나요.
네
</pre>

누가봐도 문제 있어 보이는 이 상황을 개선하기 위해 http 1.1에선 하나의 커넥션으로 여러 request, response를 주고 받을 수 있게 개선 되었다.

<pre>
여보세요 거기 중국집이죠? 여기 A동 101호인데 짜장만 하나랑요
네
여기 A동 101호인데 짬뽕하나랑요
네
여기 A동 101호인데 탕수육 하나요
</pre>

여기에 더해 파이프라이닝이란 feature도 추가된다. 파이프라이닝은 아직 보낸 요청에 응답을 받지 못했더라도 요청을 추가로 보내는 걸 말한다. 요청을 기다리지 않고 다음 요청을 보낼 수 있으니 자연스럽게 빠르게 요청을 보낼 수 있다.

<pre>
여보세요 중국집이죠? 여기 A동 101호인데 짜장면 하나, 여기 A동 101호인데 짬뽕 하나, 여기 A동 101호인데 탕수육 하나요. 

 짜장면 하나, 짬뽕 하나, 탕수육 하나요~ 네~ 
</pre>

여기까지 봤는데 상당히 거슬리는게 하나 있다. 바로 **여기 A동 101호인데**이다.

어차피 처음에 한 번만 얘기해줘도 중국집은 A동 101호인거 알텐데 모든 메뉴마다 저렇게 말할 필요가 있을까? 없다. 주문하고자 하는 메뉴가 전화의 목적이자 요청의 내용(Body)이라면 A동 101호는 부가정보다. Header 얘기를 하고 싶은거다.

이렇게 비효율적인 것은 당연히 없애고 싶다. HTTP 2.0 에선 이런 문제가 개선된다. 1.1에 비교하면 2.0은 참 많은 특징/Feature가 생기지만 그 중 헤더 내용의 중복을 제거하는 feature가 추가되었다. 덕분에 헤더의 크기는 무려 85%까지 줄어들게 된다고 한다. 

그 외에도 HTTP 2.0은 1.1에 비해 여러가지 변경된 점이 있지만 이걸 이론으로만 이해하니 사실 잘 와닿지 않는다. (사실 이번에도 한 3번째 보는것 같은데 새롭다 ㅋㅋ) 참고한 자료는 [유튜브 영상](https://www.youtube.com/watch?v=xcrjamphIp4)과 [잘 정리된 포스팅](https://www.popit.kr/%EB%82%98%EB%A7%8C-%EB%AA%A8%EB%A5%B4%EA%B3%A0-%EC%9E%88%EB%8D%98-http2/)이다.


## 문(statement)? 표현식(Expression)? 

문(Statement)는 프로그램을 구성하는 기본 단위이자 최소 실행단위다. 토큰들이 모여서 문(Statement)가 된다. 문은 표현식(expression)인 문과 표현식이 아닌 문이 있는데 표현식인 문은 `값`으로 표현이 가능하다. 

예를들면 `200 + 100`은 문이자 300이라는 값으로 표현할 수도 있어서 표현식인 문이라고 할 수 있다.
반면에 `let foo` 라는 문은 값으로 표현할 수 없기 때문에 표현식이 아닌 문이다. 더 쉽게 구분하는 방법이 있는데

1)  문 자체를 변수에 할당할 수 있다면 표현식이고

2) 문을 그대로 콘솔에 찍었을 때 undefined가 나오면 결과가 값이 아니므로 표현식이 아닌 문이다.

```jsx
/* 
1) 문 자체를 변수에 할당
*/
let x = 200 + 100;
let y = let foo;   // Error!

/*
2) 콘솔에 찍었을 때 undefined가 나오면(=결과값) 표현식이 아닌 문, 값이 나오면 표현식인 문이다.
*/
let x;   // undefined를 출력하므로 표현식 아닌 문
200+100; // 300을 출력하므로 표현식 아닌 문
```

이게 왜 중요하냐?는 아직 답할 수 없지만 나보다 몇배는 더 뛰어난 고수가 저술한 저서에서 이런 사소한 용어를 구분하는 것은 알게모르게 큰 도움이 된다고 하니 잘 알아둬서 나쁠 건 없다. 실제로 Stackoverflow 같은 곳에서 영어로 된 답변들을 참고할 때 이런 용어를 잘 구분할 수 있다면 좀 더 잘 알 수 있지 않을까