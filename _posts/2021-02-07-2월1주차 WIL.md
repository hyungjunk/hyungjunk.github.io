---
title: 2월 1주차 WIL
---

이번 주는 뭔가 단편적인 항목들을 찾아본 것들이 많다.

## 크롤링 2번째 시도에 다운로드를 성공하는 현상

캡챠를 Bypass해서 다운로드 하는 크롤링을 구현 중인데 신기한 게 첫번째 시도는 실패하고 두 번째는 된다. 

크롤러는 쿠키를 세팅하지 않나? 해서 체크해봤는데 쿠키도 잘 세팅한다. 새 창을 띄울 때 뭔가 특별한 로직이 있는지 봤는데 그냥 캡챠를 담고있는 팝업만 띄울 뿐이고 그 안에서 아무 로직도 수행하지는 않는다. JS소스를 봤는데 IFFE 코드가 있는 것도 아니다. 그런데 대체 왜 안 되는것인지 -_- ..? 어차피 cron을 돌려놓기 때문에 의도한대로 결과는 나오지만 이유는 궁금하다.


## let은 호이스팅이 안 되는가?

호이스팅이 된다. 변수는 3단계에 걸쳐 생성된다. __선언, 초기화, 할당__
선언은 말 그대로 `이 변수명 쓸거다`. 라고 선언하는 것이다. \
선언을 하면 실행 컨텍스트의 변수 객체로 등록이 된다. 여기까지는 사실 변수명 예약정도이고 실제 메모리 할당은 `초기화`를 할 때 할당이 된다. 초기화 단계에서 변수의 값이 undefined로 초기화 된다. 할당단계엔 undefined로 되어있는 현재 변수에 실제 값을 할당한다.

찾아보니 보통 아래와 같은 예제와 설명이 많았다.

```javascript
let foo = 1; // 전역 변수

{
  console.log(foo); // ReferenceError: foo is not defined
  let foo = 2; // 지역 변수
}
```
>전역 foo의 값이 출력 될 거 같은데 그렇지 않고 에러가 나는 것이 호이스팅이다

라는 설명이 많은데 이건 호이스팅보다 let이 블럭스코프 안에 있기 때문이니까 그런거 아닌가 ? 하는 생각이 들었다.

근데 생각해보면 let이 블럭스코프로 동작하려면 호이스팅이 필연적으로 일어나야 하겠구나 라는 생각이 든다. 지금 접근하려는 `let` 변수가 글로벌인지, 블럭에서 선언한 변수인지 판단하려면 그 두 개를 분간할 수 있어야 하기 때문이다.  

이를 방지하기 위해 let도 호이스팅을 하는 것이고 선언하고 아직 초기화가 되지 않은 상태에서 접근을 하려고하면 Reference Error가 난다. 이 때 변수가 선언되고 초기화 되기 전까지를 TDZ(Temporal Dead Zone)이라고 한다. 즉, 변수 사용은 할 것으로 예정되어있지만 아직 메모리 할당이 안 되어 있고 접근시 에러가 발생하는 phase이다.

var는 선언과 동시에 초기화까지 되기 때문에 에러가 아닌 undefined를 얻게 되고 const는 선언과 동시에 값의 할당이 일어나야 해서 미리 변수만 선언해둘 수 가 없다.

** 어쨌든 es6를 사용하면 var는 쓰지말고, let, const를 쓰는 게 좋은데 그 중에선 뭘 쓰는게 좋은가? 싶은 궁금증이 든 적이 있다. 감명깊게 읽었던 리액트 관련 포스팅의 저자의 블로그를 보니 그냥 용도에 맞게 쓰되 그것 고민할 시간에 암거나써라! 라고 써있어서 그냥 용도에만 맞게 사용하면 될 것 같다.


## Framework와 Library의 차이

어플리케이션의 흐름 제어권이 누구에게 있는가에 따라 구분이 달라진다. 프레임워크는 제어권을 쥐고 유저의 코드를 마치 핵심 부품처럼 사용하는 반면 라이브러리는 흐름 제어권이 유저에게 있으며 유저가 자신의 어플리케이션을 쉽게 동작할수 있게끔 도와주는 코드들이다.\
즉 프레임워크는 요구하는 규격대로 안하면 안된다. 라이브러리는 된다.

## REST

많은 API를 만들어봤지만 정확하게 사전적으로는 알지 못해서 이번 기회에 좀 찾아봤다.\
요약하면 **어떤 자원에 대한 요청을 리소스와 HTTP 메서드로 표현하여 전달하는 방식**이다.
> 내가 (어떤 자원)을 (C,R,U,D) 하고자 한다.

이 때 자원은 URI(좁게는 URL)이 표현하고 그 자원에 대해 무얼 할지를 HTTP Method로 정하는 아키텍쳐적인 제한이다. (REST는 프로토콜은 아니라고 하지만, 그냥 프로토콜이라 이해하는게 편한듯 하다)

## Testing Library를 사용할 때 어떻게 DOM에 접근할 수 있는가?

이 부분은 사용하면서도 신기했는데 이제야 찾아봤다. 실제 DOM을 만들지 않고도 어떻게 DOM을 구현했나 궁금했는데 내부적으로 jsdom 라이브러리를 사용해서 가상의 DOM을 구현한다고 한다. Testing library 저자 Kent의 팟캐스트 내용에서 발췌한 것인데 Testing library는 Jest를 사용하고 이 라이브러리 내 jsdom 패키지에서 브라우저 API들을 simulate할 수 있도록 해준다. 드래그-드랍 같은 기능까지는 못해주더라도 대부분의 기능은 지원해준다고 한다.

## React vue 공통점, 차이점

둘 다 Virtual DOM을 기반으로 한다. 큰 차이가 있다면 리액트는 라이브러리, 뷰는 프레임워크라는 것. \
리액트는 View를 편하게 보여주기 위한 라이브러리이기 때문에 라우팅이나 그 외의 부가기능들은 서드파티를 통해야 한다. 반면에 뷰는 프레임워크이기 때문에 이러한 기능들을 자체적으로 제공한다.\
또한 리액트는 자체 문법인 JSX를 뒀다. 자바스크립트가 DOM 노드를 만들고 작업하고 하는 코드를 직접 쓰기 번거로워서 JSX라는 문법을 두고 실행한다. 원래는 `React.createElement()` 이렇게 쓰기가 번거롭기 때문에 이를 편하게 쓰기 위해 JSX가 생겨난 것이고 실제로는 저런 코드로 DOM element를 만든다.\

반면에 vue는 html을 그대로 사용한다. 다만 `v-on, v-bind` 같은 vue 문법을 볼 수 있는데 이건 HTML이 오류라고 인식을 하지 않아서 사용 가능한 것이다. \
즉 뷰에서 만든 html은 html로서도 동작을 한다. (함수가 있는 한) 성능적인 면에서는 뷰가 리액트보다 더 우세한 측면이 있는듯 하다. 하지만 리액트에서 리렌더링 조절만 잘 해준다면 큰 차이 없다고 봐도 되지 않을까 싶다.

## Yarn vs npm 차이

- 설치방식: npm은 패키지를 순차적으로 설치하고 yarn은 병렬로 설치한다.
- 퍼포먼스: 거의 차이 없는데 yarn이 빠르다. 병렬로 설치해서 그런 것으로?
- 보안성: npm은 설치할 때 패키지의 dependancy에 있는 코드도 실행시키지만 yarn은 lock 파일에 있는것만 딱 설치해서 더 안전하다 하는데 현황은 확실치 않다.

이렇게 보면 yarn의 장점이 더 많아보이는데 npm도 버전업을 하면서 지속적으로 나아지는 듯 하다.

- lock file의 역할

`package.json` 은 버전 명시를 유연하게 할 수 있도록 하는데 `package-lock.json`이나 `yarn.lock`은 정확한 버전을 기재해둔다. 그래서 다른 환경에서 의존성을 실행할 때 완전히 동일한 버전을 설치하기가 가능해진다.

## CSS 이미지 스프라이트

도메인당 보통 6개의 리소스를 동시에 받을 수 있다. (서브도메인도 다른 도메인이라고 쳐진다, IE구버전은 2개, 파폭은 8개, 그외는 그냥 6개라고 보면 된다.) 그래서 이미지가 많은 경우에는 커넥션을 줄이면서 static 자원을 가져오도록 CSS 스프라이트라는 기법을 사용한다. (하나의 이미지가 여러개 이미지를 포함해서 이 이미지를 받은 후에 분배하는 것)

그래서 이론적으로는 24개의 이미지를 4개의 도메인에서 받아온다면 다 동시에 받아올 수 있어서 빨라지는데 추가적인 작업들 (DNS lookup등)으로 인해 오히려 더 느려질수도 있다고 한다.


## etc

1. CSR vs SSR

- 역시 SEO의 차이가 가장 크다고 볼 수 있다. SSR 첫 로딩이 조금 빠르다는 것도 있고.

2. Regex 쓸 때는 조심

- 정규식을 다 만족시키려고 해서 범위를 좁혀주지 않으면 매칭시간이 엄청 길어진다.

3. JS 모두 다 Float, 정확히는 Double이다.
