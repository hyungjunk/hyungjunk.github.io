---
title: 2월 2주차 WIL
---

## X-UA-Compatible

브라우저 중 IE는 버전에 맞추어 최적의 화면을 보여줄 수 있는 Compatibility 버전(모드?)을 제공한다. 웹에서는 아래와 같이 코드를 추가해서 설정해줄 수 있다.
`<meta http-equiv="X-UA-Compatible" content="IE=edge">`

IE 버전이 올라가면서 이 전의 IE 버전과 렌더링 방식이 달라지고, 그로 인해 IE 버전이 달라지면 페이지가 깨져서 나오는 현상이 발생한다. 이런 경우 `X-UA-Compatible`은 개발자가 어떤 IE 버전의 렌더링을 사용할 것인지 지정해서 그에 맞게 페이지를 보여주는 역할을 한다. 버전 별로 다른 특성이 있다. 

예를들어 위 스크립트에서 `content="IE=edge"` 대신 `content="IE=5"` 라면 IE 5 렌더링 엔진으로 페이지를 보여주고 `content=IE=7`으로 두면 IE 7버전의 렌더링 엔진이 페이지를 렌더링 하게 된다. edge는 latest, 최신 렌더링 방식을 사용한다는 뜻이다. 

예전에 IE의 점유율이 높고 IE 버전이 올라가면서 신경써야 했던 경우에 Compatibility를 위해 추가한 부분이며 `DOC type`이 HTML5라면 `IE=edge` 외에는 별로 사용할 일이 없을 것이고 실제로도 이게 권장사항이다.

## JS에서 new를 사용하는 방식이 Literal 방식보다 나은 경우

대부분의 경우 리터럴 방식이 속도도 빠르고, 가독성도 좋아서 리터럴 방식을 사용한다.\
단, 커스텀 Prototype을 만들고 해당 프로토타입의 인스턴스들이 공통으로 사용할 메서드를 정의하고 싶을 때는 new를 사용하는 방식이 더 좋을 수도 있다. [스택오버플로](https://stackoverflow.com/questions/4597926/what-is-the-difference-between-new-object-and-object-literal-notation)에서 예시를 가져왔다. 

```jsx
function Person(firstname, lastname) {
    this.firstname = firstname;
    this.lastname = lastname;
}

Person.prototype.fullname = function() {
    console.log(this.firstname + ' ' + this.lastname);
}

var zubaer = new Person('Zubaer', 'Ahammed');
var john = new Person('John', 'Doe');

zubaer.fullname();
john.fullname();
```

위 case에서 Prototype이 아닌 일반 객체로 만들었을 경우 각 객체마다 똑같은 함수를 중복으로 써줘야 하니 메모리의 낭비가 일어나지만 Prototype에 하나만 선언해두고 이를 Class method처럼 사용하면 하나의 함수만 정의하고 this를 바꿔가며 만들 수 있다.

또한 리터럴로 사용하는 것이 빠른 자세한 이유는 [https://stackoverflow.com/questions/7375120/why-is-arr-faster-than-arr-new-array](https://stackoverflow.com/questions/7375120/why-is-arr-faster-than-arr-new-array) 여기 있는데 솔직히 잘 이해되지 않는다. 

마지막 문장만 놓고 보면 **리터럴로 표기하는 경우 명확히 어떤 객체를 사용하려는 것인지 VM이 알수 있지만 new를 사용하는 경우엔 Lookup하는 과정이 필요해서 CPU를 좀 더 사용하기 때문이다**라고 하니 다시 각 잡고 읽어봐야겠다. 

## Regex Lookaround

언제나 드문드문 사용하게 되어서 헷갈리는 Regex.
그 중 더 생소한 개념인 lookaround가 있어서 좀 가지고 놀아봤다.

다만 lookaround 사용하는 경우 regex101과 regexpr이 결과가 좀 다르다. 아마 사이트간 Default 세팅 차이인 것 같은데 이유는 알지못함.

Regex를 글로 배우는 것은 의미가 없어서 뭐 괜찮은 material이 있나 보는데 [여기](https://regex101.com/quiz)서 놀아보면 좋을 것 같다.


## 클로져에서 메모리 릭 안나게 하려면?

이건 런타임 환경따라 조금씩 다른듯 하다. 크롬같은 경우엔 순환참조하는 경우 이걸 count로 치지 않아서 알아서 메모리를 해제해준다. 하지만 파폭이나 IE는 순환참조도 count한다.

[링크1](https://dev.to/divakarkumar/javascript-closure-environment-4b0k)\
[링크2](https://dzone.com/articles/resolving-circular-reference-related-memory-leaks)
