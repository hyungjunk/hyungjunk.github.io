---
title: 3월 2주차 WIL
---

## Event

웹에서 발생하는 Request를 Event라보면 웹은 Event Driven 프로그래밍이라 볼 수 있다. MDN에서 정의한 Event의 종류는 200가지가 넘는다. 어떤 액션에 이벤트 핸들러를 설정하고 싶을 때 어느 이벤트까지 가능한지 찾아보면 wheel을 다시 만들지 않고도 쉽게 기능구현을 하게 될수도 있다. (드래그 앤 드랍처럼)

특이한 건 같은 이벤트라도 버블링이 되는 이벤트가 있고 그렇지 않은 이벤트가 있다. 예를들어 mouseover, mouseenter가 있다. 둘 다 HTML요소 안으로 마우스가 이동할 떄 발생하는데 mouseenter는 이벤트 버블링이 되지 않는 반면, mouseover는 버블링이 된다. 거의 모든 이벤트가 버블링 된다는 것을 알고 있으면 된다.

버블링, 캡쳐링을 간단하게 메모해두자면, 이벤트가 발생하는 경우 이 이벤트의 근원은 브라우저 기준, window객체에서 시작을 하게 된다. DOM의 꼭대기에서 이벤트를 실제로 호출한 Target 노드까지 이벤트가 전파 되고 Target 노드를 찍고 다시 DOM의 꼭대기로 회귀하게 된다. 

이 때 Target까지 가는 과정에서 이벤트를 잡는 것을 이벤트 캡쳐링, Target을 찍고 다시 원점으로 돌아가는 과정을 이벤트 버블링이라고 한다. 마치 방울이 보글보글 올라와서 점점 커지는 모습을 형상화하면 이해하기 쉽다.

## 비동기, 이벤트루프

JS엔진은 브라우저간 Node건 실행 컨텍스트가 하나이다. 가장 기본적인 실행컨텍스트가 있고 호출하는 함수들은 이제 그 위에 Stack처럼 올라가면서 제 역할을 수행한다. 힙메모리에 각종 변수들과 자료가 저장되고 실행컨텍스트와 함수 컨텍스트가 쌓이는 콜스택에서 실행을 하는데 보통 같으면 그냥 실행 컨텍스트에 함수 컨텍스트 쌓이고 그 컨텍스트가 pop되면서 실행하는 과정의 반복이겠지만 비동기인 경우엔 얘기가 다르다.

비동기 함수는 일반 함수처럼 콜스택에 올라가고 실행되는 과정은 동일하게 겪지만 그 이후가 다르다. 일단 함수처럼 실행을 하고 실제로 해야하는 작업 혹은 로직을 메시지 큐에 넣어둔다. 그리고 이벤트 루프는 계속해서 콜스택을 감시하다가 콜스택에 아무런 함수스택이 남지 않았을 때 메세지 큐에서 대기하고 있는 함수를 실행한다.

```javascript
function(s) {
    console.log(s)
    console.log(s)
    console.log(s)
    setTimeout(console.log, 1000, s);
    console.log(s)
    console.log(s)
    console.log(s)
    console.log(s)
    ...
}
```

이처럼 `console.log` 를 끝없이 추가해둔다해도(=1초가 넘는 시간동안 console.log를 찍더라도) setTimeout에 있는 로직은 반드시 가장 나중에 실행이 된다. console.log가 콜스택에서 모두 제거가 되어야 setTimeout의 실행결과로 메시지 큐에 있던 console.log가 비로소 실행되기 때문이다.